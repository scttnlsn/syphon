{"name":"Syphon","tagline":"Immutable structure for React/Flux applications","body":"syphon\r\n====\r\n\r\n[![NPM](https://img.shields.io/npm/v/syphon.svg?style=flat)](http://npm.im/syphon)\r\n[![Build Status](https://img.shields.io/travis/scttnlsn/syphon.svg?style=flat)](https://travis-ci.org/scttnlsn/syphon)\r\n\r\nSyphon is an implementation of the [Flux](https://facebook.github.io/flux/) architectural pattern for [React](http://facebook.github.io/react/) applications inspired by [ClojureScript](https://github.com/clojure/clojurescript) and [Om](https://github.com/swannodette/om).  It helps structure your application around a single immutable state value and implements the dispatching of actions to various state-transitioning handler functions.\r\n\r\n* [Example](#example)\r\n* [State](#state)\r\n* [Handlers](#handlers)\r\n* [Dispatcher](#dispatcher)\r\n* [Components](#components)\r\n* [Observe](#observe)\r\n* [Mixin](#mixin)\r\n* [Install](#install)\r\n* [License](#license)\r\n\r\n## Example\r\n\r\n```javascript\r\nvar syphon = require('syphon');\r\n\r\nvar state = syphon.atom({ text: 'Hello World' });\r\n\r\nvar dispatcher = syphon.dispatcher();\r\n\r\ndispatcher.handler('update-text', function (state, text) {\r\n  return state.set('text', text);\r\n});\r\n\r\nvar Component = React.createClass({\r\n  mixins: [syphon.mixin],\r\n\r\n  setText: function (e) {\r\n    this.dispatch('update-text', e.currentTarget.value);\r\n  },\r\n\r\n  render: function () {\r\n    return React.DOM.div({},\r\n      React.DOM.input({ onChange: this.setText }),\r\n      React.DOM.p({}, this.props.data.get('text')));\r\n  }\r\n});\r\n\r\nsyphon.root(Component, state, {\r\n  dispatcher: dispatcher,\r\n  el: document.getElementById('app')\r\n});\r\n```\r\n\r\n## State\r\n\r\nApplication state is stored in an [immutable](http://facebook.github.io/immutable-js/) data structure and passed as a prop (called `data`) to the root component in the hierarchy.  A single mutable reference to the immutable state is held in an [atom](https://github.com/cjohansen/js-atom):\r\n\r\n```js\r\nvar state = syphon.atom({ foo: 'bar' });\r\n```\r\n\r\nTo access the value inside the atom you must `deref` it:\r\n\r\n```js\r\nvar data = state.deref();\r\n```\r\n\r\nThis will return the [Immutable.js](http://facebook.github.io/immutable-js/) data structure.  Since the data cannot be mutated directly, our only way to update the application state is to swap the atom's reference with a new state value:\r\n\r\n```js\r\nvar state = syphon.atom({ foo: 'bar' });\r\n\r\nstate.swap(function (current) {\r\n  // `current` is an Immutable.js map\r\n  console.log(current.toJS());\r\n  // => { foo: 'bar' }\r\n\r\n  // Return a new state by modifying the current state.\r\n  // Refer to the Immutable.js docs for availble methods.\r\n  return current.set('foo', 'baz');\r\n});\r\n\r\nconsole.log(state.deref().toJS());\r\n// => { foo: 'baz' }\r\n```\r\n\r\nHandlers (see below) are responsible for implementing these state transitioning functions.\r\n\r\nYou can watch for state changes via a callback:\r\n\r\n```js\r\nstate.addWatch('mywatcher', function (key, ref, old, state) {\r\n  console.log('the state is now:', state);\r\n});\r\n```\r\n\r\nRefer to the [js-atom](https://github.com/cjohansen/js-atom) docs for more information about atoms.\r\n\r\n## Handlers\r\n\r\nHandlers are functions of the form:\r\n\r\n```js\r\nfunction (state, value) {\r\n  return newState;\r\n}\r\n```\r\n\r\n* The first argument is the current (dereferenced) application state.\r\n* The remaining arguments are the values passed to `dispatch`\r\n* The handler must return a new immutable state.  Refer to the [Immutable.js](http://facebook.github.io/immutable-js/) docs for information about mofifying the state.\r\n\r\nWhile handlers are pure functions in the sense that they do not directly mutate application state, they may have other side-effects (such as making a network request or calling out to some other stateful browser API).  Since the handler functions are called synchronously, any asynchronous results must re-dispatched and handled elsewhere:\r\n\r\n```js\r\ndispatcher.handler('fetch-post', function (state, id) {\r\n  var self = this;\r\n\r\n  // Make network request\r\n  fetchPost(id, function (err, post) {\r\n    if (err) {\r\n      self.dispatch('fetch-post-error', id, err);\r\n    } else {\r\n      self.dispatch('fetch-post-success', post);\r\n    }\r\n  });\r\n\r\n  return state.set('loading', true);\r\n});\r\n\r\ndispatcher.handler('fetch-post-success', function (state, post) {\r\n  return state\r\n    .set('loading', false)\r\n    .set('post', post);\r\n});\r\n\r\ndispatcher.handler('fetch-post-error', function (state, id, err) {\r\n  return state\r\n    .set('loading', false)\r\n    .set('notice', 'There was an error fetching the post with id=' + id)\r\n    .set('error', err);\r\n});\r\n```\r\n\r\n## Dispatcher\r\n\r\nYou will typically only need a single dispatcher per application since it can coordinate multiple handlers.  To add handlers to a dispatcher either pass them to the constructor or call the `handler` function:\r\n\r\n```js\r\nvar dispatcher = syphon.dispatcher({\r\n  foo: function (state, value) { ... },\r\n  bar: function (state, value) { ... }\r\n});\r\n```\r\n\r\nor\r\n\r\n```js\r\nvar dispatcher = syphon.dispatcher();\r\n\r\ndispatcher.handler('foo', function (state, value) { ... });\r\ndispatcher.handler('bar', function (state, value) { ... });\r\n```\r\n\r\nTo dispatch an action, call the `dispatch` function, passing the handler name and any additional values:\r\n\r\n```js\r\ndispatcher.dispatch('example', 'foo', { bar: 123 });\r\n```\r\n\r\nThe dispatcher emits a `dispatch` event after each handler is called:\r\n\r\n```js\r\ndispatcher.on('dispatch', function (dispatch) {\r\n   console.log(dispatch.name);  // name of the handler invoked\r\n   console.log(dispatch.args);  // additional args passed to the handler\r\n   console.log(dispatch.state); // state returned from the handler\r\n});\r\n```\r\n\r\n## Components\r\n\r\nTo mount your component hierarchy and automatically re-render when the state changes, Syphon provides the `root` function:\r\n\r\n```js\r\nsyphon.root(MyComponent, state, {\r\n  dispatcher: dispatcher,\r\n  el: document.getElementById('app')\r\n});\r\n```\r\n\r\nOn every render, your root component will receive the current (dereferenced) state in a prop called `data`.  Your component can then pass parts of the state to child components and so on.\r\n\r\n## Observe\r\n\r\nYou may encounter cases where your data hierarchy does not directly correspond to your component hierarchy and a component needs to access application state it was not passed as a prop.  In these cases you can observe arbitrary paths in the application state:\r\n\r\n```javascript\r\nvar Component = React.createClass({\r\n  mixins: [syphon.mixin],\r\n\r\n  componentWillMount: function () {\r\n    this.text = this.observe(['path', 'to', 'text']);\r\n  },\r\n\r\n  render: function () {\r\n    return React.DOM.p({}, this.text());\r\n  }\r\n});\r\n```\r\n\r\nSyphon tracks which components are observing certain paths and ensures that they update when the application state changes at those paths.\r\n\r\n## Mixin\r\n\r\nThe Syphon mixin adds some helpers to your components that make it easier to dispatch values, observe state, and access shared data.  It also implements React's `shouldComponentUpdate` method to take advantage of fast immutable data structure equality checks.\r\n\r\nBy using the mixin you can...\r\n\r\nDispatch new actions:\r\n\r\n```js\r\nvar MyComponent = React.createClass({\r\n  mixins: [syphon.mixin],\r\n\r\n  onClick: function () {\r\n    this.dispatch('button-clicked');\r\n  }\r\n});\r\n```\r\n\r\nShare data with the entire component hierarchy:\r\n\r\n```js\r\nvar MyComponent = React.createClass({\r\n  mixins: [syphon.mixin],\r\n\r\n  componentWillMount: function () {\r\n    console.log(this.shared().foo); // => 'bar'\r\n  }\r\n});\r\n\r\nsyphon.root(MyComponent, state, {\r\n  dispatcher: dispatcher,\r\n  el: document.getElementById('app'),\r\n  shared: { foo: 'bar' }\r\n});\r\n```\r\n\r\nAnd observe application state:\r\n\r\n```javascript\r\nvar MyComponent = React.createClass({\r\n  mixins: [syphon.mixin],\r\n\r\n  componentWillMount: function () {\r\n    this.text = this.observe(['path', 'to', 'text']);\r\n  },\r\n\r\n  render: function () {\r\n    return React.DOM.p({}, this.text());\r\n  }\r\n});\r\n```\r\n\r\n## Install\r\n\r\n    npm install syphon\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014-2015 Scott Nelson\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.","google":"UA-44029969-6","note":"Don't delete this file! It's used internally to help with page regeneration."}